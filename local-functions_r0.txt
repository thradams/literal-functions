
---------------------- NXXXX Local functions ---------------------------

Author : Thiago R Adams  
Date   : 2025-08-05  
Project: ISO/IEC JTC 1/SC 22/WG 14  
Title  : Local functions
Target audience: Implementers, users

1.  ABSTRACT

   This proposal introduces support for defining functions inside the 
   scope of another function in the C language. 
        
2. RATIONALE

    C currently allows function declarations inside block scope, but not 
    function definitions. 
    
    Allowing inner function definitions would enable:

    - Better organization of code.

    - Encapsulation of helper logic that is not meaningful  outside  the
      enclosing function.

    - Avoidance of polluting the file or translation  unit  with  static 
      helper functions.

    - Complements Function Literals N3645

   Following the same principles as N3645, this proposal avoids 
   introducing closures, keeping the semantics  simple   and  compatible 
   with C's execution and memory model.

3. SYNTAX AND SEMANTICS

   3.1 Syntax
 
      block-item:
        ...
        function-definition

   Note: n3654 "Accessing the Context of Nested Functions" requires 
   static in front of local functions. In this proposal static is 
   optional.

   3.2 Semantics

       Local functions use the same scope rules as those defined for 
       function literals in N3645.
   
      * Identifiers from the enclosing scope, excluding labels, are 
        visible inside the local function scope.

      Samples:

         int main()
         {      
            enum E { A };
            int i = 0;
            void f(void)
            {
               int j = sizeof(i); //ok
               enum E e = A; //ok
            }
         }


         int main()
         {      
            L1:;
            void f(void)
            {
               //error: label 'L1' used but not defined
               goto L1; 
            }
         }
 
      * For local functions, __func__ is defined following the same 
        rules as for non-local functions. The value of __func__ is an
        implementation-defined null-terminated string when used inside
        local functions.

        Note: For comparison, GCC nested function returns the function
        name

   3.3  CONSTRAINS
      
      * The name of an object of automatic storage duration defined in 
        an enclosing function shall be referenced only in discarded 
        expressions.

      Samples:

         int main()
         {
            int i = 0;
            void f(void)
            { 
               i = 1; /*error*/ 
            };
         }

         int main()
         {
           int i = 0;
           void f(void)
           {
              int j = sizeof(i); /*ok*/ 
           }
         }

         int g;
         int main()
         {
            void f(void)
            { 
               g = 1; /*ok*/ 
            }
         }

         int main()
         {
            int f();
            void g()
            {
              f(); /*ok*/
            }      
         }

         int main()
         {
            static int i = 0;
            void f()
            { 
              i = 1; /*ok*/ 
            }
         }

      * Variably modified (VM) types defined in an enclosing scope shall
        not be referenced

         int f(int n) {
            int ar[n];
            void f()
            {
               typeof(ar) b; /*error*/ 
            }      
         }

       * An identifier declared outside the body or parameter list of a 
         local function has the enclosing block scope. 
         An identifier declared within the parameter list of a local
         function has block scope, which is the local function body 
         itself. These rules are consistent with those already in 
         effect.

      Sample:

         int main()
         {
            struct X { int i; } f (struct Y *y)
            {
               struct X x = {};
               return x;
            }

           struct X x; //ok
           struct Y y; /*error*/
         }


6.  COMPATIBILITY AND IMPACT

   * This feature does not break any existing valid C programs.
   * GCC nested functions provides an extension where captures
     are allowed.

7. EXISTING IMPLEMENTATIONS

    GCC nested functions without capturing variables.

    Cake transpiler has an implementation that converts C2Y 
    code to C99. (Missing some constrains, like usage of VM types)

    http://thradams.com/cake/playground.html  

8. REFERENCES
   
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3645.pdf
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3657.htm
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3654.pdf
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2661.pdf
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2924.pdf

